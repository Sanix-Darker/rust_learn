<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:O,mm:h}=window,M=new O.Toolbar;M.attach(h);const oe=M.render();oe.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(oe)})})()</script><script>((i,L,f,r)=>{const w=i();window.mm=w.Markmap.create("svg#mindmap",(L||w.deriveOptions)(r),f)})(()=>window.markmap,null,{"content":"Rust Learning Map","children":[{"content":"Introduction to Rust","children":[{"content":"What is Rust?","children":[{"content":"Systems programming language","children":[],"payload":{"lines":"5,6"}},{"content":"Memory safety without garbage collection","children":[],"payload":{"lines":"6,7"}},{"content":"Concurrency","children":[],"payload":{"lines":"7,8"}}],"payload":{"lines":"4,8"}},{"content":"History of Rust","children":[],"payload":{"lines":"8,9"}},{"content":"Installation","children":[{"content":"Rustup","children":[],"payload":{"lines":"10,11"}},{"content":"Cargo","children":[],"payload":{"lines":"11,13"}}],"payload":{"lines":"9,13"}}],"payload":{"lines":"3,4"}},{"content":"Basic Concepts","children":[{"content":"Syntax and Semantics","children":[{"content":"Hello World","children":[],"payload":{"lines":"15,16"}},{"content":"Comments","children":[],"payload":{"lines":"16,17"}},{"content":"Variables","children":[{"content":"Immutable by default","children":[],"payload":{"lines":"18,19"}},{"content":"Mutable variables","children":[],"payload":{"lines":"19,20"}}],"payload":{"lines":"17,20"}},{"content":"Data Types","children":[{"content":"Scalar types (integer, floating-point, boolean, character)","children":[],"payload":{"lines":"21,22"}},{"content":"Compound types (tuples, arrays)","children":[],"payload":{"lines":"22,23"}}],"payload":{"lines":"20,23"}},{"content":"Functions","children":[{"content":"Defining functions","children":[],"payload":{"lines":"24,25"}},{"content":"Function parameters","children":[],"payload":{"lines":"25,26"}},{"content":"Return values","children":[],"payload":{"lines":"26,27"}}],"payload":{"lines":"23,27"}},{"content":"Control Flow","children":[{"content":"If-else","children":[],"payload":{"lines":"28,29"}},{"content":"Loops (loop, while, for)","children":[],"payload":{"lines":"29,30"}},{"content":"Match","children":[],"payload":{"lines":"30,32"}}],"payload":{"lines":"27,32"}}],"payload":{"lines":"14,32"}}],"payload":{"lines":"13,14"}},{"content":"Ownership and Borrowing","children":[{"content":"Ownership","children":[{"content":"Ownership rules","children":[],"payload":{"lines":"34,35"}},{"content":"Variable scope","children":[],"payload":{"lines":"35,36"}},{"content":"Memory management","children":[],"payload":{"lines":"36,37"}}],"payload":{"lines":"33,37"}},{"content":"Borrowing","children":[{"content":"References","children":[],"payload":{"lines":"38,39"}},{"content":"Mutable references","children":[],"payload":{"lines":"39,40"}},{"content":"Slices","children":[],"payload":{"lines":"40,42"}}],"payload":{"lines":"37,42"}}],"payload":{"lines":"32,33"}},{"content":"Structs and Enums","children":[{"content":"Structs","children":[{"content":"Defining structs","children":[],"payload":{"lines":"44,45"}},{"content":"Tuple structs","children":[],"payload":{"lines":"45,46"}},{"content":"Unit-like structs","children":[],"payload":{"lines":"46,47"}},{"content":"Methods","children":[],"payload":{"lines":"47,48"}}],"payload":{"lines":"43,48"}},{"content":"Enums","children":[{"content":"Defining enums","children":[],"payload":{"lines":"49,50"}},{"content":"Enum variants","children":[],"payload":{"lines":"50,51"}},{"content":"Pattern matching with enums","children":[],"payload":{"lines":"51,53"}}],"payload":{"lines":"48,53"}}],"payload":{"lines":"42,43"}},{"content":"Error Handling","children":[{"content":"Panic","children":[{"content":"Unrecoverable errors","children":[],"payload":{"lines":"55,56"}},{"content":"Using panic! macro","children":[],"payload":{"lines":"56,57"}}],"payload":{"lines":"54,57"}},{"content":"Result","children":[{"content":"Recoverable errors","children":[],"payload":{"lines":"58,59"}},{"content":"Using Result enum","children":[],"payload":{"lines":"59,60"}},{"content":"Error propagation with ?","children":[],"payload":{"lines":"60,61"}}],"payload":{"lines":"57,61"}},{"content":"Option","children":[{"content":"Representing optional values","children":[],"payload":{"lines":"62,63"}},{"content":"Using Option enum","children":[],"payload":{"lines":"63,65"}}],"payload":{"lines":"61,65"}}],"payload":{"lines":"53,54"}},{"content":"Collections","children":[{"content":"Vectors","children":[{"content":"Creating vectors","children":[],"payload":{"lines":"67,68"}},{"content":"Modifying vectors","children":[],"payload":{"lines":"68,69"}},{"content":"Iterating over vectors","children":[],"payload":{"lines":"69,70"}}],"payload":{"lines":"66,70"}},{"content":"Strings","children":[{"content":"String vs &amp;str","children":[],"payload":{"lines":"71,72"}},{"content":"Creating strings","children":[],"payload":{"lines":"72,73"}},{"content":"Modifying strings","children":[],"payload":{"lines":"73,74"}}],"payload":{"lines":"70,74"}},{"content":"Hash Maps","children":[{"content":"Creating hash maps","children":[],"payload":{"lines":"75,76"}},{"content":"Modifying hash maps","children":[],"payload":{"lines":"76,77"}},{"content":"Iterating over hash maps","children":[],"payload":{"lines":"77,79"}}],"payload":{"lines":"74,79"}}],"payload":{"lines":"65,66"}},{"content":"Lifetimes","children":[{"content":"Lifetime Annotations","children":[{"content":"Function lifetimes","children":[],"payload":{"lines":"81,82"}},{"content":"Struct lifetimes","children":[],"payload":{"lines":"82,83"}},{"content":"Lifetime elision","children":[],"payload":{"lines":"83,84"}}],"payload":{"lines":"80,84"}},{"content":"Lifetime Bounds","children":[{"content":"Generic type parameters","children":[],"payload":{"lines":"85,86"}},{"content":"Lifetime bounds","children":[],"payload":{"lines":"86,88"}}],"payload":{"lines":"84,88"}}],"payload":{"lines":"79,80"}},{"content":"Generics","children":[{"content":"Defining Generics","children":[{"content":"Generic functions","children":[],"payload":{"lines":"90,91"}},{"content":"Generic structs","children":[],"payload":{"lines":"91,92"}},{"content":"Generic enums","children":[],"payload":{"lines":"92,93"}}],"payload":{"lines":"89,93"}},{"content":"Traits","children":[{"content":"Defining traits","children":[],"payload":{"lines":"94,95"}},{"content":"Implementing traits","children":[],"payload":{"lines":"95,96"}},{"content":"Trait bounds","children":[],"payload":{"lines":"96,98"}}],"payload":{"lines":"93,98"}}],"payload":{"lines":"88,89"}},{"content":"Concurrency","children":[{"content":"Threads","children":[{"content":"Spawning threads","children":[],"payload":{"lines":"100,101"}},{"content":"Thread handles","children":[],"payload":{"lines":"101,102"}},{"content":"Using join","children":[],"payload":{"lines":"102,103"}}],"payload":{"lines":"99,103"}},{"content":"Channels","children":[{"content":"Message passing","children":[],"payload":{"lines":"104,105"}},{"content":"Creating channels","children":[],"payload":{"lines":"105,106"}},{"content":"Sending and receiving messages","children":[],"payload":{"lines":"106,107"}}],"payload":{"lines":"103,107"}},{"content":"Mutex","children":[{"content":"Shared state concurrency","children":[],"payload":{"lines":"108,109"}},{"content":"Mutex locks","children":[],"payload":{"lines":"109,111"}}],"payload":{"lines":"107,111"}}],"payload":{"lines":"98,99"}},{"content":"Advanced Topics","children":[{"content":"Macros","children":[{"content":"Declarative macros","children":[],"payload":{"lines":"113,114"}},{"content":"Procedural macros","children":[],"payload":{"lines":"114,115"}},{"content":"Attribute-like macros","children":[],"payload":{"lines":"115,116"}},{"content":"Function-like macros","children":[],"payload":{"lines":"116,117"}}],"payload":{"lines":"112,117"}},{"content":"Unsafe Rust","children":[{"content":"Unsafe keyword","children":[],"payload":{"lines":"118,119"}},{"content":"Raw pointers","children":[],"payload":{"lines":"119,120"}},{"content":"Calling unsafe functions","children":[],"payload":{"lines":"120,121"}}],"payload":{"lines":"117,121"}},{"content":"Crates and Modules","children":[{"content":"Creating a crate","children":[],"payload":{"lines":"122,123"}},{"content":"Defining modules","children":[],"payload":{"lines":"123,124"}},{"content":"Re-exporting names with pub use","children":[],"payload":{"lines":"124,125"}}],"payload":{"lines":"121,125"}},{"content":"FFI (Foreign Function Interface)","children":[{"content":"Calling C code from Rust","children":[],"payload":{"lines":"126,127"}},{"content":"Creating bindings","children":[],"payload":{"lines":"127,129"}}],"payload":{"lines":"125,129"}}],"payload":{"lines":"111,112"}},{"content":"Tools and Ecosystem","children":[{"content":"Cargo","children":[{"content":"Creating a project","children":[],"payload":{"lines":"131,132"}},{"content":"Building and running","children":[],"payload":{"lines":"132,133"}},{"content":"Dependencies","children":[],"payload":{"lines":"133,134"}},{"content":"Cargo.toml","children":[],"payload":{"lines":"134,135"}}],"payload":{"lines":"130,135"}},{"content":"Rustfmt","children":[{"content":"Code formatting","children":[],"payload":{"lines":"136,137"}},{"content":"Using rustfmt","children":[],"payload":{"lines":"137,138"}}],"payload":{"lines":"135,138"}},{"content":"Clippy","children":[{"content":"Linting","children":[],"payload":{"lines":"139,140"}},{"content":"Using clippy","children":[],"payload":{"lines":"140,141"}}],"payload":{"lines":"138,141"}},{"content":"Rustdoc","children":[{"content":"Generating documentation","children":[],"payload":{"lines":"142,143"}},{"content":"Writing doc comments","children":[],"payload":{"lines":"143,144"}}],"payload":{"lines":"141,144"}},{"content":"Testing","children":[{"content":"Unit tests","children":[],"payload":{"lines":"145,146"}},{"content":"Integration tests","children":[],"payload":{"lines":"146,147"}},{"content":"Documentation tests","children":[],"payload":{"lines":"147,149"}}],"payload":{"lines":"144,149"}}],"payload":{"lines":"129,130"}},{"content":"Best Practices","children":[{"content":"Writing idiomatic Rust","children":[{"content":"Borrowing and ownership","children":[],"payload":{"lines":"151,152"}},{"content":"Error handling","children":[],"payload":{"lines":"152,153"}},{"content":"Code organization","children":[],"payload":{"lines":"153,154"}}],"payload":{"lines":"150,154"}},{"content":"Performance optimization","children":[{"content":"Profiling tools","children":[],"payload":{"lines":"155,156"}},{"content":"Efficient data structures","children":[],"payload":{"lines":"156,157"}},{"content":"Avoiding unnecessary allocations","children":[],"payload":{"lines":"157,158"}}],"payload":{"lines":"154,158"}},{"content":"Security","children":[{"content":"Safe Rust","children":[],"payload":{"lines":"159,160"}},{"content":"Auditing unsafe code","children":[],"payload":{"lines":"160,162"}}],"payload":{"lines":"158,162"}}],"payload":{"lines":"149,150"}},{"content":"Resources","children":[{"content":"Official Documentation","children":[{"content":"The Rust Programming Language (The Book)","children":[],"payload":{"lines":"164,165"}},{"content":"Rust by Example","children":[],"payload":{"lines":"165,166"}},{"content":"Rust Reference","children":[],"payload":{"lines":"166,167"}}],"payload":{"lines":"163,167"}},{"content":"Tutorials and Courses","children":[{"content":"Rustlings","children":[],"payload":{"lines":"168,169"}},{"content":"Exercism.io","children":[],"payload":{"lines":"169,170"}},{"content":"Codecademy","children":[],"payload":{"lines":"170,171"}},{"content":"Udemy","children":[],"payload":{"lines":"171,172"}}],"payload":{"lines":"167,172"}},{"content":"Books","children":[{"content":"\"Programming Rust\" by Jim Blandy and Jason Orendorff","children":[],"payload":{"lines":"173,174"}},{"content":"\"Rust in Action\" by Tim McNamara","children":[],"payload":{"lines":"174,175"}},{"content":"\"The Rust Programming Language\" by Steve Klabnik and Carol Nichols","children":[],"payload":{"lines":"175,176"}}],"payload":{"lines":"172,176"}},{"content":"Online Communities","children":[{"content":"Rust Users Forum","children":[],"payload":{"lines":"177,178"}},{"content":"Rust subreddit (r/rust)","children":[],"payload":{"lines":"178,179"}},{"content":"Rust Discord","children":[],"payload":{"lines":"179,180"}},{"content":"Stack Overflow","children":[],"payload":{"lines":"180,181"}}],"payload":{"lines":"176,181"}},{"content":"Practice Projects","children":[{"content":"Building a CLI tool","children":[],"payload":{"lines":"182,183"}},{"content":"Developing a web application with Rocket","children":[],"payload":{"lines":"183,184"}},{"content":"Creating a game with Amethyst","children":[],"payload":{"lines":"184,186"}}],"payload":{"lines":"181,186"}}],"payload":{"lines":"162,163"}},{"content":"Conclusion","children":[{"content":"Keeping up-to-date","children":[{"content":"Rust Blog","children":[],"payload":{"lines":"188,189"}},{"content":"This Week in Rust","children":[],"payload":{"lines":"189,190"}},{"content":"Rust release notes","children":[],"payload":{"lines":"190,191"}},{"content":"Community events (RustConf, RustFest)","children":[],"payload":{"lines":"191,192"}}],"payload":{"lines":"187,192"}}],"payload":{"lines":"186,187"}}],"payload":{"lines":"1,2"}},{"colorFreezeLevel":2})</script>
</body>
</html>
